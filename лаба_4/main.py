"""
Абдуллаев Шахмар ИУ7-14Б
Написана программа, которая для заданных функций выводит таблицу значений этих функций на некотором отрезке
и строит график одной из них.
Пользователь вводит начальное значение аргумента, конечное значение и шаг разбиения данного отрезка.
-1e6 1e6 5e4
"""
from math import log, e, sqrt, pow, floor  # Импорт функций и констант из библиотеки

eps = e ** (-20)  # Задан некоторый эпсилон для сравнения вещественных чисел

# Пусть задан отрезок [a, b] с шагом h
# Заданы функции:
# g1 = a^3 - 23.8a^3 + 44.9a - 10.34 (в дальнейшем может обозначаться как y, тем самым является основной функцией)
# g2 = a*ln(a) - 6
# g3 = sqrt(|g1 - g2|)

print("Вводим отрезок [a, b] с шагом h")
# invitation_text = "Введите начальное значение аргумента, конечное значение и шаг разбиения отрезка через пробел: "
# a, b, h = map(float, input(invitation_text).split())
a, b, h = 1.2, 6, 0.2
# a, b, h = -1e6, 1e6, 5e4
while b < a or h <= 0:
    if b < a:
        print("Введен некорректный отрезок: конец меньше начала! Введите новые значения")
    else:
        print("Введен некорректный шаг: шаг больше нуля! Введите новые значения")
    invitation_text = "Введите начальное значение аргумента, конечное значение и шаг разбиения отрезка через пробел: "
    a, b, h = map(float, input(invitation_text).split())


axis_length = 80  # Задана длина строки (оси)
max_y = pow(a, 3) - 23.8 * pow(a, 2) + 44.9 * 1 - 10.34  # Переменная для максимального значения функции g1
min_y = pow(a, 3) - 23.8 * pow(a, 2) + 44.9 * 1 - 10.34  # Переменная для минимального значения функции g1
max_g2 = -10 ** 10  # Переменная для максимального значения функции g2
# Создание таблицы
print("-------------------------------------------------------------")
print("|      x       |      g1      |      g2      |      g3      |")
print("-------------------------------------------------------------")
iter_x = a  # Переменная для итерации (перебора) аргумента x

if (10 ** 20 * (b - a)) % (10 ** 20 * h) <= eps:
    cnt_iter_table = round((b - a) / h + 1)
else:
    cnt_iter_table = int((b - a) // h + 1)

for _ in range(cnt_iter_table):  # Считаем количество итераций
    # Переписываем функцию g1 и считаем его значение в точке x (iter_x)
    g1 = (pow(iter_x, 3) - 23.8 * pow(iter_x, 2) + 44.9 * iter_x - 10.34)
    # Нахождение максимального и минимального значения функций
    if max_y < g1:
        max_y = g1
    if min_y > g1:
        min_y = g1
    # Проверка x на условие существование логарифма
    if iter_x > 0:
        # Считаем значения функций g2 и g3
        g2 = iter_x * log(iter_x, e) - 6
        if max_g2 < g2:  # Нахождение максимального значения функции
            max_g2 = g2
        g3 = sqrt(abs(g1 * g2))
        print(f"|{iter_x:^14.5g}|{g1:^14.5g}|{g2:^14.5g}|{g3:^14.5g}|")
    else:
        # В местах отсутствия значений g2 и g3 стоит прочерк
        print(f"|{iter_x:^14.5g}|{g1:^14.5g}|      --      |      --      |")
    iter_x += h  # Инкрементируем аргумент x (iter_x) шагом h
print("|-----------------------------------------------------------|")
delta_max = max_y - max_g2
print(f"Дополнительное задание: g1_max - g2_max = {delta_max:.5g}")

# Создание графика функции g1
print()
serif = int(input("Введите количество засечек от 4 до 8: "))
if not (4 <= serif <= 8):
    while not (4 <= serif <= 8):
        print("Введен некорректное количество засечек! Введите новое значение")
        serif = int(input("Введите количество засечек от 4 до 8: "))
print()

main_func = "y = a^3 - 23.8a^3 + 44.9a - 10.34"  # Вывод основной функции
print(f"{main_func:^90}")
print()

section = floor(axis_length / (serif - 1))  # Интервал между засечками на оси OY
start_axis = "x\y"  # Условное обозначение начала системы координат

# Вывод значений засечек на оси OY
print(f"{start_axis:<11}{min_y:<{section}.5g}", end="")  # Вывод начального значения
delta_val = abs(max_y - min_y) / (serif - 1)  # Цена деления оси OY
min_y_temp = min_y  # Переменная для вывода промежуточных y
for q in range(serif - 2):
    min_y_temp += delta_val
    print(f" {min_y_temp:<{section}.5g}", end="")
print(f" {max_y:.5g}")  # Вывод конечного значения

iter_x = a  # Переменная для итерации (перебора) аргумента x
interval = (max_y - min_y) / axis_length  # Величина диапазона значений для каждого знакоместа
min_y_iter = min_y  # Переменная для итерации (перебора) значения y
cnt_zero_space = 0  # Количество пустого знакоместа для нулевой оси
if min_y < 0:  # Проверка на наличие оси абсцисс
    while min_y_iter < 0:  # Подсчет пустого количества знакоместа для нулевой оси
        cnt_zero_space += 1
        min_y_iter += interval

for step in range(cnt_iter_table):  # Считаем количество итераций
    print(f"{iter_x:<10.5g}|", end="")  # Вывод аргумента
    # Переписываем функцию g1 и считаем его значение в точке x (iter_x)
    iter_y = pow(iter_x, 3) - 23.8 * pow(iter_x, 2) + 44.9 * iter_x - 10.34
    cnt_y_space = 0  # Количество пустого знакоместа для точки
    iter_y_temp = min_y  # Переменная для вывода промежуточных y
    # Подсчитываем количество пустого знакоместа, пока не дойдем то нужного значения точки
    while iter_y_temp < iter_y:
        cnt_y_space += 1
        iter_y_temp += interval
    # Вывод точки (либо нулевой оси, если существует)
    if cnt_zero_space == cnt_y_space or cnt_zero_space == 0:
        # Обработка ситуации, когда точка совпадает с нулевой осью или отсутствует нулевая ось
        print(" " * cnt_y_space + "*")
    elif cnt_zero_space > cnt_y_space:
        # Обработка ситуации, когда точка находится под нулевой осью
        print(" " * cnt_y_space + "*", end="")
        print(" " * (cnt_zero_space - cnt_y_space - 1) + "|")
    else:
        # Обработка ситуации, когда точка находится над нулевой осью
        print(" " * cnt_zero_space + "|", end="")
        print(" " * (cnt_y_space - cnt_zero_space - 1) + "*")
    iter_x += h  # Инкрементируем аргумент x (iter_x) шагом h
